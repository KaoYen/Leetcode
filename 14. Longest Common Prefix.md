# Description
>Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:
```py
Input: ["flower","flow","flight"]
Output: "fl"
```
Example 2:
```py
Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```
Note: All given inputs are in lowercase letters a-z.

# Solution

## Approach 1. Horizontal scanning
1.若strs鎮列為空，直接返回空字串
2.以陣列(strs)中第一個字串當成prefix
3.迭代陣列中的其他元素，比對開頭是否符合prefix字串，若有不符合的字串，將prefix減少一字元
4.重複上述步驟2.、步驟3.直到迭代的元素全部符合prefix開頭或prefix變成空字串為止

```py
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        prefix = strs[0]
        while True:
            res = True
            for s in strs:
                res = s.startswith(prefix)
                if not res:
                    prefix = prefix[:-1]
                    break
            
            if res:
                return prefix
```

### 利用 all() 函式來判斷陣列內元素是否全部符合條件，可以使代碼更加簡潔!

```py
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        prefix = strs[0] if strs else ''
        while True:
            if all(s.startswith(prefix) for s in strs):
                return prefix
            prefix = prefix[:-1]
```

### Complexity Analysis
> - 最差的情況: 如果陣列中第一個元素，也就是我們的preifx string是個很長的字串，而陣列是一個很短的字串 e.g. ['aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa', 'a']
  - 最佳情控: prefix string 本身就是答案 e.g. ['a', 'aaaaaaaaaa', 'aaaaaaaaaa', 'aaaaaaaaaa']

Time complexity : **O(S)** , where **S** is the sum of all characters in all strings.

In the worst case all n strings are the same. The algorithm compares the string **S<sub>1</sub>** with the other strings [**S<sub>2</sub>...S<sub>n</sub>**] There are **S** character comparisons, where **S** is the sum of all characters in the input array.

Space complexity : **O(1)**. We only used constant extra space.

## Approach 2: Vertical scanning
>思考一下，如果有一個很短的字串在陣列的最後，上面的方法1.一樣會做**S**次的字串比對，優化這個情況的情中一種方法就是Vertical scanning，我們先比對所有陣列中每個字串的第一個字元，再依序往後比對字串的下個字元。

